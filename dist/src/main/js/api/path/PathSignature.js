define(
    /* Class name */
    'main/api/path/PathSignature',

    /* Class dependencies */
    ['main/util/assert', 'lodash', 'main/api/path/PathParser', 'main/api/path/Root', 'main/api/path/TupleNav',
        'main/api/path/TupleStar', 'main/api/path/ArrayNav', 'main/api/path/ArrayStar', 'main/api/diff/HtmlPath',
        'main/grammar/ForwardPathSignatureGrammar', 'main/api/diff/Path'
    ],

    /* Class symbols */
    function (assert, lodash, PathParser, Root, TupleNav, TupleStar, ArrayNav, ArrayStar, HtmlPath,
              PathSignatureParser2, Path) {

        'use strict';

        var TUPLE_STAR = new TupleStar();
        var ARRAY_STAR = new ArrayStar();


        /**
         * @class A path Signature. A path signature object is immutable: all navigation methods return a new path
         * signature.
         *
         * @param {(!string|!PathStep[])} path_signature - the path signature, represented as a string or an array of path steps.
         */
        function PathSignature(path_signature) {

            // Empty constructor for private method newPathNoChecks()
            if (arguments.length === 0) {
                return;
            }

            assert(lodash.isString(path_signature) || lodash.isArray(path_signature), 'Path must be a string or an array of path steps');

            var string;
            var steps;
            if (lodash.isString(path_signature)) {

                // Parse the string
                string = path_signature;

                // PathParser2 is automatically generated by compiling the pegjs (PEG) grammar with name ForwardPathParsingGrammar.pegjs
                steps = PathSignatureParser2.parse(string);
            } else {
                // Concatenate the steps by putting '.' between TupleNav steps and '[]' between ArrayNav steps
                steps = path;
                string = steps.join('.').split('.[').join('[');
            }

            /**
             * @public
             * @type {!string}
             */
            this.string = string;

            /**
             * @public
             * @type {!PathStep[]}
             */
            this.steps = steps;

            // Immutable object
            Object.freeze(this.steps);
            Object.freeze(this);
        }

        /*
         * =============================================================================================================
         * Public accessor methods
         * =============================================================================================================
         */

        /**
         * Returns the last step.
         *
         * @returns {PathStep} the last step.
         */
        PathSignature.prototype.getLastStep = function () {
            return lodash.last(this.steps);
        };

        /**
         * Returns whether this path equals the given path.
         *
         * @param {!Path} path - the given path.
         * @returns {!boolean} whether this path equals the given path.
         */
        PathSignature.prototype.equals = function (path) {
            assert(path instanceof Path);
            return this.string === path.string;
        };

        /**
         * Returns whether this path matches the given path.
         *
         * @param {!Path || HtmlPath} path - the given path.
         * @returns {!boolean} whether this path matches the given path.
         */
        PathSignature.prototype.matches = function (path) {
            assert((path instanceof Path) || ((path instanceof HtmlPath)));

            // Both paths must have the same length
            if (this.steps.length !== path.steps.length) {
                return false;
            }

            // Every path step must match
            for (var i = 0; i<this.steps.length; i++) {
                var thisStep = this.steps[i];
                var otherStep = path.steps[i];
                var result = thisStep.matches(otherStep);
                if (result === false) {
                    return false;
                }
            }

            return true;


        };

        /*
         * =============================================================================================================
         * Public methods that create new paths
         * =============================================================================================================
         */

        /**
         * Creates a new path that is this path without the last step.
         *
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.up = function() {
            assert(this.steps.length > 1, 'Cannot navigate up from ^');
            var new_steps = lodash.clone(this.steps);
            var last_step = new_steps.pop();
            var new_string = this.string.substr(0, this.string.length - last_step.string.length);
            return newPathNoChecks(new_string, new_steps);
        };

        /**
         * Creates a new path that is the concatenation of this path and a tuple nav step using the given attribute.
         *
         * @param {!string} attribute - the attribute.
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.tupleNav = function (attribute) {
            assert(lodash.isString(attribute));
            return this.concat(new TupleNav(attribute));
        };

        /**
         * Creates a new path that is the concatenation of this path and a tuple star step.
         *
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.tupleStar = function () {
            return this.concat(TUPLE_STAR);
        };

        /**
         * Creates a new path that is the concatenation of this path and an array nav step using the given position.
         *
         * @param   {!number} position - the position.
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.arrayNav = function (position) {
            assert(lodash.isNumber(position));
            return this.concat(new ArrayNav(position));
        };

        /**
         * Creates a new path that is the concatenation of this path and an array star step.
         *
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.arrayStar = function () {
            return this.concat(ARRAY_STAR);
        };


        /**
         * Creates a new path that is the concatenation of this path and the given path step.
         *
         * @param {!PathStep} step - the path step.
         * @returns {!Path} the new path.
         */
        PathSignature.prototype.concat = function (step) {
            var new_string = this.string + step.string;
            var new_steps = lodash.clone(this.steps);
            new_steps.push(step);
            return newPathNoChecks(new_string, new_steps);
        };

        /*
         * =============================================================================================================
         * Private methods
         * =============================================================================================================
         */

        /**
         * Constructs a new path without any sanity checks.
         *
         * @param {!string}     string  - the string representation.
         * @param {!PathStep[]} steps   - the path steps.
         * @returns {!Path}     the path.
         */
        function newPathNoChecks(string, steps) {

            // Use the private constructor with no arguments
            var path = new Path();
            path.string = string;
            path.steps = steps;

            // Immutable object
            Object.freeze(path.steps);
            Object.freeze(path);

            return path;
        }

        return PathSignature;
    }
);